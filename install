#!/bin/bash
# NOTE: Lowercase variables will be exported to a file

# The below files will be forcefully removed when starting this script.
errorfile="Arch-AI_errors.log"
# The below two are only used with the deug flag enabled
debugLog="Arch-AI_debug.log"
variableLog="Arch-AI_variables.log"

# Packages that will be installed on the system with pacstrap
# the only things you are allowed to remove here would be git
# removing other things might break the setup procedure
Pacstrap=(linux linux-firmware base base-devel xorg-server xorg-xinit xorg-xrandr grub networkmanager git go)
# Required packages to run this script
Reqs=(dosfstools fzf arch-install-scripts)

Fzf_Preview="fzf --border --reverse --height 50%"
Common_Pkgs='common_pkgs'

usage="./$(basename "$0") [<flags>] -- Automatic Arch Linux install script

Flags:
    -h, --help    show this help text
    -v, --verbose toggle verbose output
    -d, --debug   toggle a simple debugging mode"

read_arguments() {
    verbose=false
    while (("$#")); do
        case "$1" in
        -v | --verbose)
            verbose=true
            ;;
        -d | --debug)
            debug=true
            ;;
        *)
            echo "Error: Unsupported flag $1" >&2
            echo "$usage"
            exit 1
            ;;
        esac
        shift
    done
}

system_check() {
    local gpus gpu

    [ $EUID -ne 0 ] &&
        prompt "This script must be run as root" red &&
        exit 1

    prompt "Updating the package database, please be patient..." yellow
    out pacman -Sy

    prompt "Checking for UEFI..." yellow
    if ls -A /sys/firmware/efi/efivars/ &>/dev/null; then
        uefi=true
        prompt "Found UEFI!" green
    fi

    prompt "Identifying GPU drivers..." yellow
    gpus=$(lspci | grep -e VGA -e 3D | tr '[:upper:]' '[:lower:]')
    log_variable "gpus" "$gpus"

    # https://wiki.archlinux.org/index.php/Xorg#Installation
    # https://wiki.archlinux.org/index.php/Hardware_video_acceleration
    for gpu in $gpus; do
        case "$gpu" in
        # https://wiki.archlinux.org/index.php/Intel_graphics
        *"intel"*)
            prompt "Intel GPU found!" green
            add_pkg mesa
            add_pkg vulkan-intel
            # HW acceleration
            add_pkg intel-media-driver
            add_pkg libva-intel-driver
            # 2D acceleration in Xorg
            add_pkg xf86-video-intel
            ;;
            # https://wiki.archlinux.org/index.php/AMDGPU
        *"amd"*)
            prompt "AMD GPU found!" green
            add_pkg mesa
            add_pkg vulkan-radeon
            # HW acceleration
            add_pkg libva-mesa-driver
            add_pkg mesa-vdpau
            # 2D acceleration in Xorg
            add_pkg xf86-video-amdgpu
            ;;
            # https://wiki.archlinux.org/index.php/NVIDIA
        *"nvidia"*)
            prompt "Nvidia GPU found!" green
            add_pkg nvidia
            add_pkg nvidia-utils
            # HW acceleration
            add_pkg libva-mesa-driver
            add_pkg mesa-vdpau
            ;;
        esac
    done
}

# Installs missing requirements for this script (if any)
# and updates the mirrorlist if needed
installReqs() {
    if ! grep -q Reflector /etc/pacman.d/mirrorlist; then
        prompt "Installing reflector..." yellow
        out pacman -S reflector --needed --noconfirm
        prompt "Generating new pacman mirrors, please be patient..." yellow
        reflector --verbose --latest 150 --sort rate --save /etc/pacman.d/mirrorlist
    fi

    prompt "Installing additional packages if required..." yellow
    out pacman -S "${Reqs[@]}" --needed --noconfirm
}

# Get username, hostname, password, locale
get_config() {
    local locale_list pass1 pass2 root1 root2

    locale_list="$(grep UTF-8 /etc/locale.gen | awk '{print $1}' | cut -c 2-)"
    # TODO, the US.UTF-8 option is uncommented in the Arch Linux
    # live ISO, so for now I'll add it as an option manually
    locale_list+=$(printf "\nen.US.UTF-8")
    log_variable "locale_list" "$locale_list"

    while [[ -z $locale ]]; do
        prompt "Which locale would you like?" blue
        locale=$(echo "$locale_list" | $Fzf_Preview)
    done
    while true; do
        iprompt "What hostname would you like?" false
        # shellcheck disable=SC2154
        hostname="$Reply"
        iprompt "What username would you like?" false
        uName="$Reply"
        [[ -n $uName && -n $hostname ]] && break
        prompt "Username, hostname or the root password was left blank, try again." red
    done

    # Get user password
    while true; do
        iprompt "What password would you like for ${uName}?" true
        pass1="$Reply"
        echo
        iprompt "Confirm password for $uName" true
        pass2="$Reply"
        echo
        if [ -z "$pass1" ]; then
            prompt "Password left blank, try again." red
        elif [ "$pass1" == "$pass2" ]; then
            # userPass is written to info file
            # shellcheck disable=SC2034
            userPass="$pass1"
            break
        else
            prompt "Passwords do not match, try again." red
        fi
    done

    # Get root password
    while true; do
        iprompt "What password would you like for the root user?" true
        root1="$Reply"
        echo
        iprompt "Confirm password for the root user" true
        root2="$Reply"
        echo
        if [ -z "$root1" ]; then
            prompt "Password left blank, try again." red
        elif [ "$root1" == "$root2" ]; then
            # userPass is written to info file
            # shellcheck disable=SC2034
            rootPW="$root1"
            break
        else
            prompt "Passwords do not match, try again." red
        fi
    done
}

get_micro() {
    local cpu
    printf "\033[1;34mWould you like to install microcode updates for your CPU? (Y/n)\033[0m "
    read -rn 1 && [[ $REPLY =~ ^[Nn]$ ]] && return
    echo

    prompt "Identifying the CPU drivers..." yellow
    cpu=$(cat /proc/cpuinfo | grep vendor | tr '[:upper:]' '[:lower:]')
    log_variable "cpu" "$cpu"
    case "$cpu" in
    *"intel"*)
        prompt "Intel CPU found!" green
        add_pkg intel-ucode
        ;;
        # TODO, no clue AMD processors contains "AMD" in vendor_id
    *"amd"*)
        prompt "AMD CPU found!" green
        add_pkg amd-ucode
        ;;
    esac
}

# TODO check trim
# TODO use funciton to ask questions
# https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM
# shellcheck disable=SC2034
get_misc() {
    printf "\033[1;34mWould you like to auto-trim your mounted SSDs once a week? (Y/n)\033[0m "
    read -rn 1 && [[ ! $REPLY =~ ^[Nn]$ ]] && enableSSDTRIM=true &&
        add_pkg util-linux

    printf "\n\033[1;34mWould you like to enable kernel parameters to allow for hibernation? [EXPERIMENTAL] (Y/n)\033[0m "
    read -rn 1 && [[ ! $REPLY =~ ^[Nn]$ ]] && enableHibernation=true

    printf "\n\033[1;34mWould you like to enable parallel and optimized compilation&compression for makepkg? (Y/n)\033[0m "
    read -rn 1 && [[ ! $REPLY =~ ^[Nn]$ ]] && makepkgParallel=true
    printf "\n"
}

# Ask for some additional popular packages
get_pkgs() {
    local choice choices

    prompt "Would you like to install any additional common packages? (Use <Tab>)" blue
    choices=$($Fzf_Preview -m <"$Common_Pkgs")
    for choice in $choices; do
        add_pkg "$(grep "$choice" "$Common_Pkgs" | cut -d' ' -f1)"
    done
}

# Adds a package to be pacstrapped
add_pkg() {
    # Add package to list if not already there
    [[ ${Pacstrap[*]} != *"$1"* ]] && Pacstrap+=("$1")
}

# Asks which drive arch should be installed to
get_drive() {
    local drives numDrives choice
    lsblk
    echo
    drives=$(find /dev/sd*[a-z] | sort)
    log_variable "drives" "$drives"
    numDrives=$(echo "$drives" | wc -w)
    log_variable "numDrives" "$numDrives"

    echo "$drives" | awk '{print NR,$0}'
    while [[ $choice -le 0 || $choice -gt $numDrives ]]; do
        read -r -p "Which drive would you like to install Arch on [1-$numDrives]: " choice
    done

    # fs contains the base path to the drive
    # such as /dev/sda
    fs=$(echo "$drives" | sed -n "$choice"p)
    log_variable "fs" "$fs"

    if [[ -z $fs ]]; then
        prompt "Something went wrong!" red
        exit 1
    fi

    local re='^[0-9]+$'
    while ! [[ $RootSize =~ $re ]]; do
        read -r -p "How big should the root partition be [GB]:" RootSize
    done

    while ! [[ $SwapSize =~ $re ]]; do
        read -r -p "How big should the swap partition be [GB]:" SwapSize
    done

    while ! [[ $HomeSize =~ $re ]]; do
        prompt "Type 0 to fill the remaining space on the disk selected" yellow
        read -r -p "Type out the size of the home partition [GB]:" HomeSize
    done

    # Set formatting of the variables
    # so that fdisk can use them
    RootSize="+${RootSize}G"
    SwapSize="+${SwapSize}G"
    [ "$HomeSize" != "0" ] && HomeSize="+${HomeSize}G"

    # Setup paths to the different
    # partitions on the hard drive
    bl="${fs}"1
    swap="${fs}"2
    root="${fs}"3
    home="${fs}"4

    log_variable "bl" "$bl"
    log_variable "swap" "$swap"
    log_variable "root" "$root"
    log_variable "home" "$home"
}

verify() {
    printf "Username: %s\nLocale: %s\nHostname: %s\n\n" "$uName" "$locale" "$hostname"
    printf "Installation drive: %s\nHome partition: %s\nRoot partition: %s\nSwap partition: %s\nUEFI enabled: %s\n\n" "$fs" "$HomeSize" "$RootSize" "$SwapSize" "$uefi"
    printf "Packages: %s\n" "${Pacstrap[*]}"
    read -rn 1 -p "Continue with install? (y/N)" && [[ ! $REPLY =~ ^[Yy]$ ]] &&
        prompt "Installation cancelled!" red && exit
    echo
}

# 1=bootloader, 2=swap, 3=root, 4=home
format_fs() {
    while swapon --show | grep -q "$fs"; do
        prompt "$fs seems to have swap partition, trying to disable it!" red
        swapoff "$(swapon --show | grep "$fs" | awk '{ print $1}')"
    done

    while df | grep -q "$fs"; do
        prompt "$fs seems to have some partion(s) mounted, trying to unmount!" red
        ls "$fs"?* | xargs -n1 umount -l
        sleep 1
    done
    # Wipe drive
    out wipefs -a "$fs"

    prompt "Creating partitions..." yellow
    (
        # GPT > MBR
        echo g

        if [[ -n $uefi ]]; then
            mkpart "+512M"
            # Set partition type to 'EFI System'
            echo t
            echo 1
        else
            mkpart "+200M"
            # Set partition type to 'BIOS boot'
            echo t
            echo 4
        fi

        mkpart "$SwapSize"
        # Set partition type to 'Linux Swap'
        echo t
        echo 2
        echo 19

        mkpart "$RootSize"
        # Set partition type to 'Linux root (x86-64)'
        echo t
        echo 3
        echo 24

        # Either fill the rest of the drive, or the chosen amount
        ([[ $HomeSize -eq 0 ]] && mkpart) || mkpart "$HomeSize"
        # Set partition type to 'Linux home'
        echo t
        echo 4
        echo 28 # Linux home
        echo w
    ) | out fdisk "$fs"

    prompt "Formatting partitions..." yellow
    out mkfs.fat -F32 "$bl"
    out mkswap -L SWAP_PARTITION "$swap"
    out swapon "$swap"
    out mkfs.ext4 -F "$root"
    out mkfs.ext4 -F "$home"

    prompt "Setting partition labels..." yellow
    out e2label "$root" ROOT_PARTITION
    out e2label "$home" HOME_PARTITION
    out e2label "$bl" BOOT_PARTITION

    prompt "Mounting $root and ${home}..." yellow
    out mount "$root" /mnt
    out mkdir /mnt/home
    out mount "$home" /mnt/home
}

# sequence for creating a new partition
# 1: size of partition
mkpart() {
    echo n
    echo
    echo
    echo "$1"
    # Partition x contain signature message
    echo "y"
}

arch_install() {
    prompt "The script will now install and set up your system" green
    prompt "No further input will be needed" green
    sleep 2
    prompt "Pacstrapping packages..." yellow
    pacstrap /mnt "${Pacstrap[@]}"
    prompt "Generating the fstab..." yellow
    out genfstab -U /mnt >/mnt/etc/fstab
}

# chroot into the new arch installation
jumpChroot() {
    # export all the current lowercase
    # variables into an info file
    (
        set -o posix
        set
    ) | grep -Ev '^([A-Z]|.$)' >/mnt/info

    cp setup /mnt/setup
    cp sharedfuncs /mnt/sharedfuncs
    chmod 554 /mnt/setup

    # Move files to the new arch installation
    mv "$errorfile" /mnt/"$errorfile"
    errorfile="/$errorfile"
    if [[ -n $debug ]]; then
        mv "$debugLog" "$variableLog" /mnt/"$debugLog"
        debugLog="/$debugLog"
        variableLog="/$variableLog"
        less </mnt/info
    fi

    # Launch the setup script
    arch-chroot /mnt /bin/bash <<"EOF"
./setup
EOF
}

# out logs the errors to the errorfile
# and then echos output of commands
# if verbose is true
out() {
    # TODO add verbose and very verose option
    # TODO cleanup the things I don't know what they're doing
    local lines
    echo "COMMAND: $*" >>$errorfile
    # TODO I have no clue why I wrote this
    lines="$(wc -l <$errorfile)"

    if [[ -n $debug ]]; then
        {
            echo "COMMAND: $*"
            "$@"
        } >>$debugLog 2>&1
    else
        ("$verbose" && "$@" 2>>$errorfile) || "$@" 1>/dev/null 2>>$errorfile
    fi

    # TODO I have no clue why I wrote this
    [ "$lines" == "$(wc -l <$errorfile)" ] && sed -i '$ d' $errorfile
}

# log_variable logs the contents of a variable to the variableLog if the debug flag is set
# 1: name of variable
# 2: content
log_variable() {
    [[ -n $debug ]] &&
        printf "=-=-=-=-=-=-=-=-=-=-= %s =-=-=-=-=-=-=-=-=-=-=\n%s\n" "$1" "$2" >>"$variableLog"
}

# shellcheck disable=SC2178
# shellcheck disable=SC2179
# shellcheck disable=SC2128
# Interactive prompt, reads the reply to the $Reply variable
# 1: message
# 2: [true, false] silent mode
iprompt() {
    local cmd
    printf "\033[1;34m%s: \033[0m" "$1"
    cmd="read -r"
    $2 && cmd+="s"
    $cmd Reply
}

main() {
    # TODO, will be uncommented when script is stable
    source sharedfuncs
    # Remove files from previous runs
    rm -f "$errorfile" "$debugLog" "$variableLog"
    read_arguments "$@"
    prompt "Running in non chrooted mode!" green
    system_check
    installReqs
    get_config
    get_micro
    get_misc
    get_pkgs
    get_drive
    verify
    format_fs
    arch_install
    jumpChroot
    prompt "Arch Linux successfully installed!" green
}

main "$@"
